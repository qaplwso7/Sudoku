# Project - Sudoku

# Главные части проекта:
1) Class Sudoku
2) function backtrack
3) Методы в название которых входит solve и solution
4) Применение модуля Theard и Pygame
5) Отрисовка всего интерфейса

# Class SudokuGame
В классе SudokuGame реализована логика игры "Судоку" с графическим интерфейсом на PyGame.

При создании объекта класса инициализируются все необходимые атрибуты:
- Два игровых поля (grid и initial_grid) размером 9x9, заполненные нулями
- Переменные для хранения выбранной клетки (selected), количества решений (solution_count)
- Списки для отображения ошибок (error_cells) и системных сообщений (message)
- Визуализация (цвета, анимации)
- Флаги режимов (edit_mode для редактирования поля)

# Bactrack
**Алгоритм поиска с возвратом (бэктрекинг), адаптированный для решения судоку. Сначала алгоритм проверяет, достигнут ли лимит решений (max_solutions), и если да - устанавливает флаг solution_limit_reached и завершает работу. Если текущая строка равна 9, значит все предыдущие строки успешно заполнены - это признак найденного решения, поэтому увеличивается счетчик solution_count. При достижении конца столбцов (col == 9) функция переходит к следующей строке. Если текущая клетка уже содержит число (не ноль), происходит переход к следующей клетке. Каждое число проверяется на валидность с помощью метода _is_valid, который убеждается, что число не встречается в текущей строке, столбце и малом квадрате 3×3. Если число подходит, оно записывается в текущую клетку, и функция рекурсивно вызывает саму себя для следующей клетки. Если рекурсивный вызов не приводит к решению, происходит откат - число из клетки удаляется (присваивается 0), и пробуется следующее значение. Этот процесс продолжается, пока не будут перебраны все возможные варианты или не будет достигнут лимит решений.**

# Методы solve и solution
Solve и Solution - два(их больше, но я беру все методы, где хоть как то присутствуют данные названия) типа методов, которые работают с копией исходного поля, чтобы не нарушать его состояние, и могут запускаться в отдельном потоке, чтобы не блокировать интерфейс. Результаты их работы (найденное решение или количество решений) сохраняются в атрибутах класса для последующего отображения.

# Методы Draw
Отрисовка интерфейса и игрового поля реализована в методах draw, draw_interface и draw_loading_indicator. Основной метод draw заполняет экран темным фоном, затем рисует игровое поле как прямоугольник с сеткой 9x9, где линии разделяют блоки 3x3. Цифры отображаются разными цветами: бирюзовым для введенных пользователем, светло-зеленым для исходных, красным для ошибочных и желтым в режиме редактирования. Выбранная клетка выделяется зеленой рамкой. Метод draw_interface рисует панель управления под игровым полем с пятью кнопками ("Решить", "Решения", "Новая", "Сброс", "Редакт."), каждая из которых имеет свой цвет. Отображается статус игры: количество найденных решений или сообщения системы (например, "Новая игра создана!"), которые исчезают через несколько секунд. При длительных операциях (поиск решений) появляется анимация вращающегося индикатора загрузки с меняющимся цветом. В самом низу экрана выводится подсказка по управлению - используемые клавиши и их назначение.

# Sudoku
*Классическая судоку — логическая головоломка с числами, где нужно заполнить сетку размером 9×9, разделённую на подблоки 3×3, цифрами от 1 до 9. Часть клеток уже заполнена цифрами-подсказками, остальные — пустые.*

*Правила Судоку:*
*1) В каждой горизонтальной строке должны быть все цифры 1–9 без повторений.
2) В каждом вертикальном столбце тоже должны быть все цифры 1–9 без повторов.
3) Внутри каждого выделенного квадрата 3×3 нельзя повторять цифры — от 1 до 9 по одному разу на блок.*

Пример работы программы:

<img src="https://github.com/user-attachments/assets/bb9825b0-ae99-4ad4-9c0d-2532badd73f6" alt="Alt Text" width="300" height="450"> |
<img src="https://github.com/user-attachments/assets/95625ae1-4b54-4475-b2c5-132a07e11d22" alt="Alt Text" width="300" height="450"> |
<img src="https://github.com/user-attachments/assets/1ad79cbe-b752-4d09-aab1-cf7545d349f5" alt="Alt Text" width="300" height="450"> |
<img src="https://github.com/user-attachments/assets/13243634-f170-4414-b37c-f56627c747bc" alt="Alt Text" width="300" height="450"> |
<img src="https://github.com/user-attachments/assets/de94c804-8c78-4672-96e6-cabbaf803323" alt="Alt Text" width="300" height="450"> |
<img src="https://github.com/user-attachments/assets/95e630e0-83b5-449f-89c0-980d9858d5de" alt="Alt Text" width="300" height="450">

**При включении программы сразу задается пустое поле, после чего моментально находится случайное решение. Нажав на R - "Решить" мы сгенерируем другое случайное решение, которое должно было образоваться на пустой доске. Нажав на N - "Новая" мы создаем новую игру/новое поле, которое уже является верным, рассматривая с точки зрения правил игры судоку. Нажав на С - "Решения" мы увидим вращающийся и переливающийся разными цветами круглый индикатор и подсчет количества решений. Если программа найдет больше 2000 решений, то она завершит поиск новых решений(данный параметр мы можем поменять). Если найдет все решения, не дойдя до 2000, то выведет сколько решений программа нашла. Также мы можешь задавать любые решения для сгенерированного поля. Есть параметры для сброса всей сетки Судоку, а также ее редактирования. При редактировании мы не просто вставляем значения, а генерируем сетку, которую нам и нужно будет решить. Также праграмма является и обычной Судоку, стрелочками мы можем выбирать место на поле и решать данную головоломку, мы можем удалить только введеные значения.**




# Вывод
Впервые открыл для себя игру под название Sudoku. Было интересно почитать про различные алгоритмы для решения данной игры, находил много разных, например: Backtracking, Algorithm X, Constraint Propagation. Я выбрал Backtracking - он очень прост в реализации и он отлично подходит для моего проекта. Было очень-очень интересно работать с модулем Pygame, чем глубже в него погружаешься тем интереснее. Также использовал модуль Theard - он мне понадобился для создания потоков, чтобы добавить интерактивности в свой интерфейс, например: вращение индикатора, вывод некоторых данных. Работая над другим проектом(в котором я ускорял вычисления) я знал, что использовать обычные списки и кортежи Python невыгодно для вычислений и времени, поэтому подключив модуль NumPy я создал подходящие для работы массивы и не беспокоился о скорости своих вычислений. Самое самое сложное что было в реализации - интерфейс(возможно я не умею с ним правильно работать). Из этого проекта я получил много информации, которая укрепила знания по Python. При работе над проектом использовал Habr, GeeksforGeeks, stack Overflow и ИИ.




